# Definition for a binary tree node.
import heapq
import unittest

# Read about enumerate in python
from collections import defaultdict, deque
from typing import List

class MinimizeMalwareSpreadII(unittest.TestCase):

    def minMalwareSpread(self, graph: List[List[int]], initialList: List[int]) -> int:

        def bfs(graph: List[List[int]], start: int, initial: List[int]) -> set:
            forbiddenNodes = set(initial)
            bfsQueue = deque([start])
            visited = {start}
            numOfNodes = len(graph)

            while bfsQueue:
                head = bfsQueue.popleft()
                for neighbor in range(numOfNodes):
                    if graph[head][neighbor] == 1 and neighbor not in forbiddenNodes and neighbor not in visited:
                        visited.add(neighbor)
                        bfsQueue.append(neighbor)

            return visited

        # for each initial, compute a set of nodes which will be directly impacted
        # output: nodeToInitial[node] = set(initial1, initial2, )
        nodeToDirectlyConnectedInitials = defaultdict(set)
        for oneInitial in initialList:
            directlyConnectedNodes = bfs(graph, oneInitial, initialList)
            for directNode in directlyConnectedNodes:
                nodeToDirectlyConnectedInitials[directNode].add(oneInitial)

        # for each initial, count the number of directly impacted nodes
        # output: graph[initial] -> count, loop through and take the minimum
        impactedNumOfNodes = defaultdict(lambda: 0)
        for key,value in nodeToDirectlyConnectedInitials.items():
            if len(value) > 1:
                continue
            else:
                for init in value:
                    impactedNumOfNodes[init] += 1

        result = (initialList[0], 0)
        for key, value in impactedNumOfNodes.items():
            if result[1] < value:
                result = (key, value)
            elif result[1] == value:
                result = (min(result[0], key), value)
            else:
                continue

        return result[0]

    def test_Leetcode(self):
        self.assertEqual(0, self.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))
        self.assertEqual(1, self.minMalwareSpread([[1,1,0],[1,1,1],[0,1,1]], [0,1]))
        self.assertEqual(1, self.minMalwareSpread([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], [0,1]))

    def test_Edgecase(self):
        self.assertEqual(1, self.minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [1, 2]))

if __name__ == '__main__':
    unittest.main()