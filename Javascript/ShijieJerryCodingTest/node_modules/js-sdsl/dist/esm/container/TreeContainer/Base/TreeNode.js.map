{"version":3,"sources":["container/TreeContainer/Base/TreeNode.js","../../src/container/TreeContainer/Base/TreeNode.ts"],"names":["__extends","this","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","TreeNode","key","value","color","_left","undefined","_right","_parent","_key","_value","_color","_pre","preNode","isRootOrHeader","pre","_next","nextNode","_rotateLeft","PP","V","R","_rotateRight","F","K","TreeNodeEnableIndex","_super","_this","apply","arguments","_subTreeSize","parent","_recount"],"mappings":"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","file":"TreeNode.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TreeNode = /** @class */ (function () {\n    function TreeNode(key, value, color) {\n        if (color === void 0) { color = 1 /* TreeNodeColor.RED */; }\n        this._left = undefined;\n        this._right = undefined;\n        this._parent = undefined;\n        this._key = key;\n        this._value = value;\n        this._color = color;\n    }\n    /**\n     * @description Get the pre node.\n     * @returns TreeNode about the pre node.\n     */\n    TreeNode.prototype._pre = function () {\n        var preNode = this;\n        var isRootOrHeader = preNode._parent._parent === preNode;\n        if (isRootOrHeader && preNode._color === 1 /* TreeNodeColor.RED */) {\n            preNode = preNode._right;\n        }\n        else if (preNode._left) {\n            preNode = preNode._left;\n            while (preNode._right) {\n                preNode = preNode._right;\n            }\n        }\n        else {\n            // Must be root and left is null\n            if (isRootOrHeader) {\n                return preNode._parent;\n            }\n            var pre = preNode._parent;\n            while (pre._left === preNode) {\n                preNode = pre;\n                pre = preNode._parent;\n            }\n            preNode = pre;\n        }\n        return preNode;\n    };\n    /**\n     * @description Get the next node.\n     * @returns TreeNode about the next node.\n     */\n    TreeNode.prototype._next = function () {\n        var nextNode = this;\n        if (nextNode._right) {\n            nextNode = nextNode._right;\n            while (nextNode._left) {\n                nextNode = nextNode._left;\n            }\n            return nextNode;\n        }\n        else {\n            var pre = nextNode._parent;\n            while (pre._right === nextNode) {\n                nextNode = pre;\n                pre = nextNode._parent;\n            }\n            if (nextNode._right !== pre) {\n                return pre;\n            }\n            else\n                return nextNode;\n        }\n    };\n    /**\n     * @description Rotate left.\n     * @returns TreeNode about moved to original position after rotation.\n     */\n    TreeNode.prototype._rotateLeft = function () {\n        var PP = this._parent;\n        var V = this._right;\n        var R = V._left;\n        if (PP._parent === this)\n            PP._parent = V;\n        else if (PP._left === this)\n            PP._left = V;\n        else\n            PP._right = V;\n        V._parent = PP;\n        V._left = this;\n        this._parent = V;\n        this._right = R;\n        if (R)\n            R._parent = this;\n        return V;\n    };\n    /**\n     * @description Rotate right.\n     * @returns TreeNode about moved to original position after rotation.\n     */\n    TreeNode.prototype._rotateRight = function () {\n        var PP = this._parent;\n        var F = this._left;\n        var K = F._right;\n        if (PP._parent === this)\n            PP._parent = F;\n        else if (PP._left === this)\n            PP._left = F;\n        else\n            PP._right = F;\n        F._parent = PP;\n        F._right = this;\n        this._parent = F;\n        this._left = K;\n        if (K)\n            K._parent = this;\n        return F;\n    };\n    return TreeNode;\n}());\nexport { TreeNode };\nvar TreeNodeEnableIndex = /** @class */ (function (_super) {\n    __extends(TreeNodeEnableIndex, _super);\n    function TreeNodeEnableIndex() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._subTreeSize = 1;\n        return _this;\n    }\n    /**\n     * @description Rotate left and do recount.\n     * @returns TreeNode about moved to original position after rotation.\n     */\n    TreeNodeEnableIndex.prototype._rotateLeft = function () {\n        var parent = _super.prototype._rotateLeft.call(this);\n        this._recount();\n        parent._recount();\n        return parent;\n    };\n    /**\n     * @description Rotate right and do recount.\n     * @returns TreeNode about moved to original position after rotation.\n     */\n    TreeNodeEnableIndex.prototype._rotateRight = function () {\n        var parent = _super.prototype._rotateRight.call(this);\n        this._recount();\n        parent._recount();\n        return parent;\n    };\n    TreeNodeEnableIndex.prototype._recount = function () {\n        this._subTreeSize = 1;\n        if (this._left) {\n            this._subTreeSize += this._left._subTreeSize;\n        }\n        if (this._right) {\n            this._subTreeSize += this._right._subTreeSize;\n        }\n    };\n    return TreeNodeEnableIndex;\n}(TreeNode));\nexport { TreeNodeEnableIndex };\n","export const enum TreeNodeColor {\n  RED = 1,\n  BLACK = 0\n}\n\nexport class TreeNode<K, V> {\n  _color: TreeNodeColor;\n  _key: K | undefined;\n  _value: V | undefined;\n  _left: TreeNode<K, V> | undefined = undefined;\n  _right: TreeNode<K, V> | undefined = undefined;\n  _parent: TreeNode<K, V> | undefined = undefined;\n  constructor(\n    key?: K,\n    value?: V,\n    color: TreeNodeColor = TreeNodeColor.RED\n  ) {\n    this._key = key;\n    this._value = value;\n    this._color = color;\n  }\n  /**\n   * @description Get the pre node.\n   * @returns TreeNode about the pre node.\n   */\n  _pre() {\n    let preNode: TreeNode<K, V> = this;\n    const isRootOrHeader = preNode._parent!._parent === preNode;\n    if (isRootOrHeader && preNode._color === TreeNodeColor.RED) {\n      preNode = preNode._right!;\n    } else if (preNode._left) {\n      preNode = preNode._left;\n      while (preNode._right) {\n        preNode = preNode._right;\n      }\n    } else {\n      // Must be root and left is null\n      if (isRootOrHeader) {\n        return preNode._parent!;\n      }\n      let pre = preNode._parent!;\n      while (pre._left === preNode) {\n        preNode = pre;\n        pre = preNode._parent!;\n      }\n      preNode = pre;\n    }\n    return preNode;\n  }\n  /**\n   * @description Get the next node.\n   * @returns TreeNode about the next node.\n   */\n  _next() {\n    let nextNode: TreeNode<K, V> = this;\n    if (nextNode._right) {\n      nextNode = nextNode._right;\n      while (nextNode._left) {\n        nextNode = nextNode._left;\n      }\n      return nextNode;\n    } else {\n      let pre = nextNode._parent!;\n      while (pre._right === nextNode) {\n        nextNode = pre;\n        pre = nextNode._parent!;\n      }\n      if (nextNode._right !== pre) {\n        return pre;\n      } else return nextNode;\n    }\n  }\n  /**\n   * @description Rotate left.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const PP = this._parent!;\n    const V = this._right!;\n    const R = V._left;\n\n    if (PP._parent === this) PP._parent = V;\n    else if (PP._left === this) PP._left = V;\n    else PP._right = V;\n\n    V._parent = PP;\n    V._left = this;\n\n    this._parent = V;\n    this._right = R;\n\n    if (R) R._parent = this;\n\n    return V;\n  }\n  /**\n   * @description Rotate right.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const PP = this._parent!;\n    const F = this._left!;\n    const K = F._right;\n\n    if (PP._parent === this) PP._parent = F;\n    else if (PP._left === this) PP._left = F;\n    else PP._right = F;\n\n    F._parent = PP;\n    F._right = this;\n\n    this._parent = F;\n    this._left = K;\n\n    if (K) K._parent = this;\n\n    return F;\n  }\n}\n\nexport class TreeNodeEnableIndex<K, V> extends TreeNode<K, V> {\n  _subTreeSize = 1;\n  /**\n   * @description Rotate left and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateLeft() {\n    const parent = super._rotateLeft() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  /**\n   * @description Rotate right and do recount.\n   * @returns TreeNode about moved to original position after rotation.\n   */\n  _rotateRight() {\n    const parent = super._rotateRight() as TreeNodeEnableIndex<K, V>;\n    this._recount();\n    parent._recount();\n    return parent;\n  }\n  _recount() {\n    this._subTreeSize = 1;\n    if (this._left) {\n      this._subTreeSize += (this._left as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n    if (this._right) {\n      this._subTreeSize += (this._right as TreeNodeEnableIndex<K, V>)._subTreeSize;\n    }\n  }\n}\n"]}