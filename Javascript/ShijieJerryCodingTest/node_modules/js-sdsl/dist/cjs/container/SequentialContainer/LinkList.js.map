{"version":3,"sources":["container/SequentialContainer/LinkList.js","../../src/container/SequentialContainer/LinkList.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_ContainerBase","_throwError","obj","__esModule","LinkListIterator","ContainerIterator","constructor","_node","_header","container","iteratorType","super","this","pre","_pre","throwIteratorAccessError","next","_next","pointer","_value","newValue","copy","isAccessible","LinkList","SequentialContainer","_head","_tail","self","forEach","el","pushBack","_eraseNode","node","L","B","_length","_insertNode","clear","begin","end","rBegin","rEnd","front","back","getElementByPos","pos","RangeError","curNode","eraseElementByPos","eraseElementByValue","eraseElementByIterator","iter","element","popBack","pushFront","popFront","setElementByPos","insert","num","i","find","reverse","pHead","pTail","cnt","tmp","unique","tmpNode","sort","cmp","arr","push","merge","list","callback","index","Symbol","iterator","_default"],"mappings":"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","file":"LinkList.js","sourcesContent":["import SequentialContainer from './Base';\nimport { ContainerIterator } from \"../ContainerBase\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass LinkListIterator extends ContainerIterator {\n    /**\n     * @internal\n     */\n    constructor(_node, _header, container, iteratorType) {\n        super(iteratorType);\n        this._node = _node;\n        this._header = _header;\n        this.container = container;\n        if (this.iteratorType === 0 /* IteratorType.NORMAL */) {\n            this.pre = function () {\n                if (this._node._pre === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._pre;\n                return this;\n            };\n            this.next = function () {\n                if (this._node === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._next;\n                return this;\n            };\n        }\n        else {\n            this.pre = function () {\n                if (this._node._next === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._next;\n                return this;\n            };\n            this.next = function () {\n                if (this._node === this._header) {\n                    throwIteratorAccessError();\n                }\n                this._node = this._node._pre;\n                return this;\n            };\n        }\n    }\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        return this._node._value;\n    }\n    set pointer(newValue) {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        this._node._value = newValue;\n    }\n    copy() {\n        return new LinkListIterator(this._node, this._header, this.container, this.iteratorType);\n    }\n    isAccessible() {\n        return this._node !== this._header;\n    }\n}\nclass LinkList extends SequentialContainer {\n    constructor(container = []) {\n        super();\n        this._header = {};\n        this._head = this._tail = this._header._pre = this._header._next = this._header;\n        const self = this;\n        container.forEach(function (el) {\n            self.pushBack(el);\n        });\n    }\n    /**\n     * @internal\n     */\n    _eraseNode(node) {\n        const { _pre, _next } = node;\n        _pre._next = _next;\n        _next._pre = _pre;\n        if (node === this._head) {\n            this._head = _next;\n        }\n        if (node === this._tail) {\n            this._tail = _pre;\n        }\n        this._length -= 1;\n    }\n    /**\n     * @internal\n     */\n    _insertNode(value, pre) {\n        const next = pre._next;\n        const node = {\n            _value: value,\n            _pre: pre,\n            _next: next\n        };\n        pre._next = node;\n        next._pre = node;\n        if (pre === this._header) {\n            this._head = node;\n        }\n        if (next === this._header) {\n            this._tail = node;\n        }\n        this._length += 1;\n    }\n    clear() {\n        this._length = 0;\n        this._head = this._tail = this._header._pre = this._header._next = this._header;\n    }\n    begin() {\n        return new LinkListIterator(this._head, this._header, this);\n    }\n    end() {\n        return new LinkListIterator(this._header, this._header, this);\n    }\n    rBegin() {\n        return new LinkListIterator(this._tail, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new LinkListIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        return this._head._value;\n    }\n    back() {\n        return this._tail._value;\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let curNode = this._head;\n        while (pos--) {\n            curNode = curNode._next;\n        }\n        return curNode._value;\n    }\n    eraseElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let curNode = this._head;\n        while (pos--) {\n            curNode = curNode._next;\n        }\n        this._eraseNode(curNode);\n        return this._length;\n    }\n    eraseElementByValue(_value) {\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            if (curNode._value === _value) {\n                this._eraseNode(curNode);\n            }\n            curNode = curNode._next;\n        }\n        return this._length;\n    }\n    eraseElementByIterator(iter) {\n        const node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        iter = iter.next();\n        this._eraseNode(node);\n        return iter;\n    }\n    pushBack(element) {\n        this._insertNode(element, this._tail);\n        return this._length;\n    }\n    popBack() {\n        if (this._length === 0)\n            return;\n        const value = this._tail._value;\n        this._eraseNode(this._tail);\n        return value;\n    }\n    /**\n     * @description Push an element to the front.\n     * @param element - The element you want to push.\n     * @returns The size of queue after pushing.\n     */\n    pushFront(element) {\n        this._insertNode(element, this._header);\n        return this._length;\n    }\n    /**\n     * @description Removes the first element.\n     * @returns The element you popped.\n     */\n    popFront() {\n        if (this._length === 0)\n            return;\n        const value = this._head._value;\n        this._eraseNode(this._head);\n        return value;\n    }\n    setElementByPos(pos, element) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let curNode = this._head;\n        while (pos--) {\n            curNode = curNode._next;\n        }\n        curNode._value = element;\n    }\n    insert(pos, element, num = 1) {\n        if (pos < 0 || pos > this._length) {\n            throw new RangeError();\n        }\n        if (num <= 0)\n            return this._length;\n        if (pos === 0) {\n            while (num--)\n                this.pushFront(element);\n        }\n        else if (pos === this._length) {\n            while (num--)\n                this.pushBack(element);\n        }\n        else {\n            let curNode = this._head;\n            for (let i = 1; i < pos; ++i) {\n                curNode = curNode._next;\n            }\n            const next = curNode._next;\n            this._length += num;\n            while (num--) {\n                curNode._next = {\n                    _value: element,\n                    _pre: curNode\n                };\n                curNode._next._pre = curNode;\n                curNode = curNode._next;\n            }\n            curNode._next = next;\n            next._pre = curNode;\n        }\n        return this._length;\n    }\n    find(element) {\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            if (curNode._value === element) {\n                return new LinkListIterator(curNode, this._header, this);\n            }\n            curNode = curNode._next;\n        }\n        return this.end();\n    }\n    reverse() {\n        if (this._length <= 1) {\n            return this;\n        }\n        let pHead = this._head;\n        let pTail = this._tail;\n        let cnt = 0;\n        while ((cnt << 1) < this._length) {\n            const tmp = pHead._value;\n            pHead._value = pTail._value;\n            pTail._value = tmp;\n            pHead = pHead._next;\n            pTail = pTail._pre;\n            cnt += 1;\n        }\n        return this;\n    }\n    unique() {\n        if (this._length <= 1) {\n            return this._length;\n        }\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            let tmpNode = curNode;\n            while (tmpNode._next !== this._header &&\n                tmpNode._value === tmpNode._next._value) {\n                tmpNode = tmpNode._next;\n                this._length -= 1;\n            }\n            curNode._next = tmpNode._next;\n            curNode._next._pre = curNode;\n            curNode = curNode._next;\n        }\n        return this._length;\n    }\n    sort(cmp) {\n        if (this._length <= 1) {\n            return this;\n        }\n        const arr = [];\n        this.forEach(function (el) {\n            arr.push(el);\n        });\n        arr.sort(cmp);\n        let curNode = this._head;\n        arr.forEach(function (element) {\n            curNode._value = element;\n            curNode = curNode._next;\n        });\n        return this;\n    }\n    /**\n     * @description Merges two sorted lists.\n     * @param list - The other list you want to merge (must be sorted).\n     * @returns The size of list after merging.\n     * @example\n     * const linkA = new LinkList([1, 3, 5]);\n     * const linkB = new LinkList([2, 4, 6]);\n     * linkA.merge(linkB);  // [1, 2, 3, 4, 5];\n     */\n    merge(list) {\n        const self = this;\n        if (this._length === 0) {\n            list.forEach(function (el) {\n                self.pushBack(el);\n            });\n        }\n        else {\n            let curNode = this._head;\n            list.forEach(function (el) {\n                while (curNode !== self._header &&\n                    curNode._value <= el) {\n                    curNode = curNode._next;\n                }\n                self._insertNode(el, curNode._pre);\n            });\n        }\n        return this._length;\n    }\n    forEach(callback) {\n        let curNode = this._head;\n        let index = 0;\n        while (curNode !== this._header) {\n            callback(curNode._value, index++, this);\n            curNode = curNode._next;\n        }\n    }\n    *[Symbol.iterator]() {\n        if (this._length === 0)\n            return;\n        let curNode = this._head;\n        while (curNode !== this._header) {\n            yield curNode._value;\n            curNode = curNode._next;\n        }\n    }\n}\nexport default LinkList;\n","import SequentialContainer from './Base';\nimport { ContainerIterator, initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\ntype LinkNode<T> = {\n  _value: T;\n  _pre: LinkNode<T>;\n  _next: LinkNode<T>;\n}\n\nclass LinkListIterator<T> extends ContainerIterator<T> {\n  readonly container: LinkList<T>;\n  /**\n   * @internal\n   */\n  _node: LinkNode<T>;\n  /**\n   * @internal\n   */\n  private readonly _header: LinkNode<T>;\n  /**\n   * @internal\n   */\n  constructor(\n    _node: LinkNode<T>,\n    _header: LinkNode<T>,\n    container: LinkList<T>,\n    iteratorType?: IteratorType\n  ) {\n    super(iteratorType);\n    this._node = _node;\n    this._header = _header;\n    this.container = container;\n    if (this.iteratorType === IteratorType.NORMAL) {\n      this.pre = function () {\n        if (this._node._pre === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre;\n        return this;\n      };\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next;\n        return this;\n      };\n    } else {\n      this.pre = function () {\n        if (this._node._next === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._next;\n        return this;\n      };\n      this.next = function () {\n        if (this._node === this._header) {\n          throwIteratorAccessError();\n        }\n        this._node = this._node._pre;\n        return this;\n      };\n    }\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    return this._node._value;\n  }\n  set pointer(newValue: T) {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    this._node._value = newValue;\n  }\n  copy() {\n    return new LinkListIterator<T>(this._node, this._header, this.container, this.iteratorType);\n  }\n  isAccessible() {\n    return this._node !== this._header;\n  }\n  // @ts-ignore\n  equals(iter: LinkListIterator<T>): boolean;\n  // @ts-ignore\n  pre(): this;\n  // @ts-ignore\n  next(): this;\n}\n\nexport type { LinkListIterator };\n\nclass LinkList<T> extends SequentialContainer<T> {\n  /**\n   * @internal\n   */\n  private _head: LinkNode<T>;\n  /**\n   * @internal\n   */\n  private _tail: LinkNode<T>;\n  /**\n   * @internal\n   */\n  private readonly _header: LinkNode<T>;\n  constructor(container: initContainer<T> = []) {\n    super();\n    this._header = <LinkNode<T>>{};\n    this._head = this._tail = this._header._pre = this._header._next = this._header;\n    const self = this;\n    container.forEach(function (el) {\n      self.pushBack(el);\n    });\n  }\n  /**\n   * @internal\n   */\n  private _eraseNode(node: LinkNode<T>) {\n    const { _pre, _next } = node;\n    _pre._next = _next;\n    _next._pre = _pre;\n    if (node === this._head) {\n      this._head = _next;\n    }\n    if (node === this._tail) {\n      this._tail = _pre;\n    }\n    this._length -= 1;\n  }\n  /**\n   * @internal\n   */\n  private _insertNode(value: T, pre: LinkNode<T>) {\n    const next = pre._next;\n    const node = {\n      _value: value,\n      _pre: pre,\n      _next: next\n    };\n    pre._next = node;\n    next._pre = node;\n    if (pre === this._header) {\n      this._head = node;\n    }\n    if (next === this._header) {\n      this._tail = node;\n    }\n    this._length += 1;\n  }\n  clear() {\n    this._length = 0;\n    this._head = this._tail = this._header._pre = this._header._next = this._header;\n  }\n  begin() {\n    return new LinkListIterator<T>(this._head, this._header, this);\n  }\n  end() {\n    return new LinkListIterator<T>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new LinkListIterator<T>(this._tail, this._header, this, IteratorType.REVERSE);\n  }\n  rEnd() {\n    return new LinkListIterator<T>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front(): T | undefined {\n    return this._head._value;\n  }\n  back(): T | undefined {\n    return this._tail._value;\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let curNode = this._head;\n    while (pos--) {\n      curNode = curNode._next;\n    }\n    return curNode._value;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let curNode = this._head;\n    while (pos--) {\n      curNode = curNode._next;\n    }\n    this._eraseNode(curNode);\n    return this._length;\n  }\n  eraseElementByValue(_value: T) {\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      if (curNode._value === _value) {\n        this._eraseNode(curNode);\n      }\n      curNode = curNode._next;\n    }\n    return this._length;\n  }\n  eraseElementByIterator(iter: LinkListIterator<T>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    iter = iter.next();\n    this._eraseNode(node);\n    return iter;\n  }\n  pushBack(element: T) {\n    this._insertNode(element, this._tail);\n    return this._length;\n  }\n  popBack() {\n    if (this._length === 0) return;\n    const value = this._tail._value;\n    this._eraseNode(this._tail);\n    return value;\n  }\n  /**\n   * @description Push an element to the front.\n   * @param element - The element you want to push.\n   * @returns The size of queue after pushing.\n   */\n  pushFront(element: T) {\n    this._insertNode(element, this._header);\n    return this._length;\n  }\n  /**\n   * @description Removes the first element.\n   * @returns The element you popped.\n   */\n  popFront() {\n    if (this._length === 0) return;\n    const value = this._head._value;\n    this._eraseNode(this._head);\n    return value;\n  }\n  setElementByPos(pos: number, element: T) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let curNode = this._head;\n    while (pos--) {\n      curNode = curNode._next;\n    }\n    curNode._value = element;\n  }\n  insert(pos: number, element: T, num = 1) {\n    $checkWithinAccessParams!(pos, 0, this._length);\n    if (num <= 0) return this._length;\n    if (pos === 0) {\n      while (num--) this.pushFront(element);\n    } else if (pos === this._length) {\n      while (num--) this.pushBack(element);\n    } else {\n      let curNode = this._head;\n      for (let i = 1; i < pos; ++i) {\n        curNode = curNode._next;\n      }\n      const next = curNode._next;\n      this._length += num;\n      while (num--) {\n        curNode._next = <LinkNode<T>>{\n          _value: element,\n          _pre: curNode\n        };\n        curNode._next._pre = curNode;\n        curNode = curNode._next;\n      }\n      curNode._next = next;\n      next._pre = curNode;\n    }\n    return this._length;\n  }\n  find(element: T) {\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      if (curNode._value === element) {\n        return new LinkListIterator<T>(curNode, this._header, this);\n      }\n      curNode = curNode._next;\n    }\n    return this.end();\n  }\n  reverse() {\n    if (this._length <= 1) {\n      return this;\n    }\n    let pHead = this._head;\n    let pTail = this._tail;\n    let cnt = 0;\n    while ((cnt << 1) < this._length) {\n      const tmp = pHead._value;\n      pHead._value = pTail._value;\n      pTail._value = tmp;\n      pHead = pHead._next;\n      pTail = pTail._pre;\n      cnt += 1;\n    }\n    return this;\n  }\n  unique() {\n    if (this._length <= 1) {\n      return this._length;\n    }\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      let tmpNode = curNode;\n      while (\n        tmpNode._next !== this._header &&\n        tmpNode._value === tmpNode._next._value\n      ) {\n        tmpNode = tmpNode._next;\n        this._length -= 1;\n      }\n      curNode._next = tmpNode._next;\n      curNode._next._pre = curNode;\n      curNode = curNode._next;\n    }\n    return this._length;\n  }\n  sort(cmp?: (x: T, y: T) => number) {\n    if (this._length <= 1) {\n      return this;\n    }\n    const arr: T[] = [];\n    this.forEach(function (el) {\n      arr.push(el);\n    });\n    arr.sort(cmp);\n    let curNode: LinkNode<T> = this._head;\n    arr.forEach(function (element) {\n      curNode._value = element;\n      curNode = curNode._next;\n    });\n    return this;\n  }\n  /**\n   * @description Merges two sorted lists.\n   * @param list - The other list you want to merge (must be sorted).\n   * @returns The size of list after merging.\n   * @example\n   * const linkA = new LinkList([1, 3, 5]);\n   * const linkB = new LinkList([2, 4, 6]);\n   * linkA.merge(linkB);  // [1, 2, 3, 4, 5];\n   */\n  merge(list: LinkList<T>) {\n    const self = this;\n    if (this._length === 0) {\n      list.forEach(function (el) {\n        self.pushBack(el);\n      });\n    } else {\n      let curNode = this._head;\n      list.forEach(function (el) {\n        while (\n          curNode !== self._header &&\n          curNode._value <= el\n        ) {\n          curNode = curNode._next;\n        }\n        self._insertNode(el, curNode._pre);\n      });\n    }\n    return this._length;\n  }\n  forEach(callback: (element: T, index: number, list: LinkList<T>) => void) {\n    let curNode = this._head;\n    let index = 0;\n    while (curNode !== this._header) {\n      callback(curNode._value, index++, this);\n      curNode = curNode._next;\n    }\n  }\n  * [Symbol.iterator]() {\n    if (this._length === 0) return;\n    let curNode = this._head;\n    while (curNode !== this._header) {\n      yield curNode._value;\n      curNode = curNode._next;\n    }\n  }\n}\n\nexport default LinkList;\n"]}