{"version":3,"sources":["container/TreeContainer/OrderedMap.js","../../src/container/TreeContainer/OrderedMap.ts"],"names":["Object","defineProperty","exports","value","default","_Base","_interopRequireDefault","require","_TreeIterator","_throwError","obj","__esModule","OrderedMapIterator","TreeIterator","constructor","node","header","container","iteratorType","super","this","pointer","_node","_header","throwIteratorAccessError","self","Proxy","get","target","prop","_key","_value","set","_","newValue","TypeError","copy","OrderedMap","TreeContainer","cmp","enableIndex","forEach","el","setElement","begin","_left","end","rBegin","_right","rEnd","front","_length","minNode","back","maxNode","lowerBound","key","resNode","_lowerBound","_root","upperBound","_upperBound","reverseLowerBound","_reverseLowerBound","reverseUpperBound","_reverseUpperBound","callback","_inOrderTraversal","index","map","hint","_set","getElementByPos","pos","RangeError","find","curNode","_getTreeNodeByKey","getElementByKey","union","other","Symbol","iterator","length","nodeList","i","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACLvB,IAAAC,QAAAC,uBAAAC,QAAA;;AACA,IAAAC,gBAAAF,uBAAAC,QAAA;;AAIA,IAAAE,cAAAF,QAAA;;AAA8D,SAAAD,uBAAAI;IAAA,OAAAA,KAAAA,EAAAC,IAAAD,IAAA;QAAAN,SAAAM;;AAAA;;AAE9D,MAAME,2BAAiCC,cAAAA;IAErCC,WAAAA,CACEC,GACAC,GACAC,GACAC;QAEAC,MAAMJ,GAAMC,GAAQE;QACpBE,KAAKH,YAAYA;ADRjB;ICUF,WAAII;QACF,IAAID,KAAKE,MAAUF,KAAKG,GAAS;aAC/B,GAAAC,YAAAA;ADRE;QCUJ,MAAMC,IAAOL;QACb,OAAO,IAAIM,MAAuB,IAAI;YACpCC,GAAAA,CAAIC,GAAQC;gBACV,IAAIA,MAAS,KAAK,OAAOJ,EAAKH,EAAMQ,QAC/B,IAAID,MAAS,KAAK,OAAOJ,EAAKH,EAAMS;gBACzCH,EAAO,KAAKH,EAAKH,EAAMQ;gBACvBF,EAAO,KAAKH,EAAKH,EAAMS;gBACvB,OAAOH,EAAOC;ADNV;YCQNG,GAAAA,CAAIC,GAAGJ,GAAWK;gBAChB,IAAIL,MAAS,KAAK;oBAChB,MAAM,IAAIM,UAAU;ADNd;gBCQRV,EAAKH,EAAMS,IAASG;gBACpB,OAAO;ADNH;;AAER;ICQFE,IAAAA;QACE,OAAO,IAAIxB,mBACTQ,KAAKE,GACLF,KAAKG,GACLH,KAAKH,WACLG,KAAKF;ADVP;;;ACmBJ,MAAMmB,mBAAyBC,MAAAA;IAW7BxB,WAAAA,CACEG,IAAmC,IACnCsB,GACAC;QAEArB,MAAMoB,GAAKC;QACX,MAAMf,IAAOL;QACbH,EAAUwB,SAAQ,SAAUC;YAC1BjB,EAAKkB,WAAWD,EAAG,IAAIA,EAAG;ADpBxB;AACJ;ICsBFE,KAAAA;QACE,OAAO,IAAIhC,mBAAyBQ,KAAKG,EAAQsB,KAASzB,KAAKG,GAASH,KAAKG,GAASH;ADpBtF;ICsBF0B,GAAAA;QACE,OAAO,IAAIlC,mBAAyBQ,KAAKG,GAASH,KAAKG,GAASH;ADpBhE;ICsBF2B,MAAAA;QACE,OAAO,IAAInC,mBACTQ,KAAKG,EAAQyB,KAAU5B,KAAKG,GAC5BH,KAAKG,GACLH,MAAI;ADvBN;IC2BF6B,IAAAA;QACE,OAAO,IAAIrC,mBAAyBQ,KAAKG,GAASH,KAAKG,GAASH,MAAI;ADzBpE;IC2BF8B,KAAAA;QACE,IAAI9B,KAAK+B,MAAY,GAAG;QACxB,MAAMC,IAAUhC,KAAKG,EAAQsB;QAC7B,OAAe,EAACO,EAAQtB,GAAMsB,EAAQrB;ADxBtC;IC0BFsB,IAAAA;QACE,IAAIjC,KAAK+B,MAAY,GAAG;QACxB,MAAMG,IAAUlC,KAAKG,EAAQyB;QAC7B,OAAe,EAACM,EAAQxB,GAAMwB,EAAQvB;ADvBtC;ICyBFwB,UAAAA,CAAWC;QACT,MAAMC,IAAUrC,KAAKsC,EAAYtC,KAAKuC,GAAOH;QAC7C,OAAO,IAAI5C,mBAAyB6C,GAASrC,KAAKG,GAASH;ADvB3D;ICyBFwC,UAAAA,CAAWJ;QACT,MAAMC,IAAUrC,KAAKyC,EAAYzC,KAAKuC,GAAOH;QAC7C,OAAO,IAAI5C,mBAAyB6C,GAASrC,KAAKG,GAASH;ADvB3D;ICyBF0C,iBAAAA,CAAkBN;QAChB,MAAMC,IAAUrC,KAAK2C,EAAmB3C,KAAKuC,GAAOH;QACpD,OAAO,IAAI5C,mBAAyB6C,GAASrC,KAAKG,GAASH;ADvB3D;ICyBF4C,iBAAAA,CAAkBR;QAChB,MAAMC,IAAUrC,KAAK6C,EAAmB7C,KAAKuC,GAAOH;QACpD,OAAO,IAAI5C,mBAAyB6C,GAASrC,KAAKG,GAASH;ADvB3D;ICyBFqB,OAAAA,CAAQyB;QACN9C,KAAK+C,IAAkB,SAAUpD,GAAMqD,GAAOC;YAC5CH,EAAiB,EAACnD,EAAKe,GAAMf,EAAKgB,KAASqC,GAAOC;ADvBhD;AACJ;ICqCF1B,UAAAA,CAAWa,GAAQrD,GAAUmE;QAC3B,OAAOlD,KAAKmD,EAAKf,GAAKrD,GAAOmE;ADvB7B;ICyBFE,eAAAA,CAAgBC;QDvBV,ICwBsBA,IAAG,KAAHA,IAAQrD,KAAK+B,IAAO,GArItB;YAAC,MAAU,IAAIuB;AD+GnC;QCuBJ,MAAM3D,IAAOK,KAAK+C,GAAkBM;QACpC,OAAe,EAAC1D,EAAKe,GAAMf,EAAKgB;ADrBhC;ICuBF4C,IAAAA,CAAKnB;QACH,MAAMoB,IAAUxD,KAAKyD,GAAkBzD,KAAKuC,GAAOH;QACnD,OAAO,IAAI5C,mBAAyBgE,GAASxD,KAAKG,GAASH;ADrB3D;IC6BF0D,eAAAA,CAAgBtB;QACd,MAAMoB,IAAUxD,KAAKyD,GAAkBzD,KAAKuC,GAAOH;QACnD,OAAOoB,EAAQ7C;ADrBf;ICuBFgD,KAAAA,CAAMC;QACJ,MAAMvD,IAAOL;QACb4D,EAAMvC,SAAQ,SAAUC;YACtBjB,EAAKkB,WAAWD,EAAG,IAAIA,EAAG;ADrBxB;QCuBJ,OAAOtB,KAAK+B;ADrBZ;ICuBF,GAAG8B,OAAOC;QACR,MAAMC,IAAS/D,KAAK+B;QACpB,MAAMiC,IAAWhE,KAAK+C;QACtB,KAAK,IAAIkB,IAAI,GAAGA,IAAIF,KAAUE,GAAG;YAC/B,MAAMtE,IAAOqE,EAASC;kBACR,EAACtE,EAAKe,GAAMf,EAAKgB;ADrB7B;AACJ;;;ACyBH,IAAAuD,WAEcjD;;AAAUnC,QAAAE,UAAAkF","file":"OrderedMap.js","sourcesContent":["import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass OrderedMapIterator extends TreeIterator {\n    constructor(node, header, container, iteratorType) {\n        super(node, header, iteratorType);\n        this.container = container;\n    }\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        const self = this;\n        return new Proxy([], {\n            get(target, prop) {\n                if (prop === '0')\n                    return self._node._key;\n                else if (prop === '1')\n                    return self._node._value;\n                target[0] = self._node._key;\n                target[1] = self._node._value;\n                return target[prop];\n            },\n            set(_, prop, newValue) {\n                if (prop !== '1') {\n                    throw new TypeError('prop must be 1');\n                }\n                self._node._value = newValue;\n                return true;\n            }\n        });\n    }\n    copy() {\n        return new OrderedMapIterator(this._node, this._header, this.container, this.iteratorType);\n    }\n}\nclass OrderedMap extends TreeContainer {\n    /**\n     * @param container - The initialization container.\n     * @param cmp - The compare function.\n     * @param enableIndex - Whether to enable iterator indexing function.\n     * @example\n     * new OrderedMap();\n     * new OrderedMap([[0, 1], [2, 1]]);\n     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n     * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n     */\n    constructor(container = [], cmp, enableIndex) {\n        super(cmp, enableIndex);\n        const self = this;\n        container.forEach(function (el) {\n            self.setElement(el[0], el[1]);\n        });\n    }\n    begin() {\n        return new OrderedMapIterator(this._header._left || this._header, this._header, this);\n    }\n    end() {\n        return new OrderedMapIterator(this._header, this._header, this);\n    }\n    rBegin() {\n        return new OrderedMapIterator(this._header._right || this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new OrderedMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        if (this._length === 0)\n            return;\n        const minNode = this._header._left;\n        return [minNode._key, minNode._value];\n    }\n    back() {\n        if (this._length === 0)\n            return;\n        const maxNode = this._header._right;\n        return [maxNode._key, maxNode._value];\n    }\n    lowerBound(key) {\n        const resNode = this._lowerBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    upperBound(key) {\n        const resNode = this._upperBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    reverseLowerBound(key) {\n        const resNode = this._reverseLowerBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    reverseUpperBound(key) {\n        const resNode = this._reverseUpperBound(this._root, key);\n        return new OrderedMapIterator(resNode, this._header, this);\n    }\n    forEach(callback) {\n        this._inOrderTraversal(function (node, index, map) {\n            callback([node._key, node._value], index, map);\n        });\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key - The key want to insert.\n     * @param value - The value want to set.\n     * @param hint - You can give an iterator hint to improve insertion efficiency.\n     * @return The size of container after setting.\n     * @example\n     * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n     * const iter = mp.begin();\n     * mp.setElement(1, 0);\n     * mp.setElement(3, 0, iter);  // give a hint will be faster.\n     */\n    setElement(key, value, hint) {\n        return this._set(key, value, hint);\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const node = this._inOrderTraversal(pos);\n        return [node._key, node._value];\n    }\n    find(key) {\n        const curNode = this._getTreeNodeByKey(this._root, key);\n        return new OrderedMapIterator(curNode, this._header, this);\n    }\n    /**\n     * @description Get the value of the element of the specified key.\n     * @param key - The specified key you want to get.\n     * @example\n     * const val = container.getElementByKey(1);\n     */\n    getElementByKey(key) {\n        const curNode = this._getTreeNodeByKey(this._root, key);\n        return curNode._value;\n    }\n    union(other) {\n        const self = this;\n        other.forEach(function (el) {\n            self.setElement(el[0], el[1]);\n        });\n        return this._length;\n    }\n    *[Symbol.iterator]() {\n        const length = this._length;\n        const nodeList = this._inOrderTraversal();\n        for (let i = 0; i < length; ++i) {\n            const node = nodeList[i];\n            yield [node._key, node._value];\n        }\n    }\n}\nexport default OrderedMap;\n","import TreeContainer from './Base';\nimport TreeIterator from './Base/TreeIterator';\nimport { TreeNode } from './Base/TreeNode';\nimport { initContainer, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass OrderedMapIterator<K, V> extends TreeIterator<K, V> {\n  container: OrderedMap<K, V>;\n  constructor(\n    node: TreeNode<K, V>,\n    header: TreeNode<K, V>,\n    container: OrderedMap<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(target, prop: '0' | '1') {\n        if (prop === '0') return self._node._key!;\n        else if (prop === '1') return self._node._value!;\n        target[0] = self._node._key!;\n        target[1] = self._node._value!;\n        return target[prop];\n      },\n      set(_, prop: '1', newValue: V) {\n        if (prop !== '1') {\n          throw new TypeError('prop must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new OrderedMapIterator<K, V>(\n      this._node,\n      this._header,\n      this.container,\n      this.iteratorType\n    );\n  }\n  // @ts-ignore\n  equals(iter: OrderedMapIterator<K, V>): boolean;\n}\n\nexport type { OrderedMapIterator };\n\nclass OrderedMap<K, V> extends TreeContainer<K, V> {\n  /**\n   * @param container - The initialization container.\n   * @param cmp - The compare function.\n   * @param enableIndex - Whether to enable iterator indexing function.\n   * @example\n   * new OrderedMap();\n   * new OrderedMap([[0, 1], [2, 1]]);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y);\n   * new OrderedMap([[0, 1], [2, 1]], (x, y) => x - y, true);\n   */\n  constructor(\n    container: initContainer<[K, V]> = [],\n    cmp?: (x: K, y: K) => number,\n    enableIndex?: boolean\n  ) {\n    super(cmp, enableIndex);\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new OrderedMapIterator<K, V>(this._header._left || this._header, this._header, this);\n  }\n  end() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new OrderedMapIterator<K, V>(\n      this._header._right || this._header,\n      this._header,\n      this,\n      IteratorType.REVERSE\n    );\n  }\n  rEnd() {\n    return new OrderedMapIterator<K, V>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    const minNode = this._header._left!;\n    return <[K, V]>[minNode._key, minNode._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    const maxNode = this._header._right!;\n    return <[K, V]>[maxNode._key, maxNode._value];\n  }\n  lowerBound(key: K) {\n    const resNode = this._lowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  upperBound(key: K) {\n    const resNode = this._upperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseLowerBound(key: K) {\n    const resNode = this._reverseLowerBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  reverseUpperBound(key: K) {\n    const resNode = this._reverseUpperBound(this._root, key);\n    return new OrderedMapIterator<K, V>(resNode, this._header, this);\n  }\n  forEach(callback: (element: [K, V], index: number, map: OrderedMap<K, V>) => void) {\n    this._inOrderTraversal(function (node, index, map) {\n      callback(<[K, V]>[node._key, node._value], index, map);\n    });\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param hint - You can give an iterator hint to improve insertion efficiency.\n   * @return The size of container after setting.\n   * @example\n   * const mp = new OrderedMap([[2, 0], [4, 0], [5, 0]]);\n   * const iter = mp.begin();\n   * mp.setElement(1, 0);\n   * mp.setElement(3, 0, iter);  // give a hint will be faster.\n   */\n  setElement(key: K, value: V, hint?: OrderedMapIterator<K, V>) {\n    return this._set(key, value, hint);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    return <[K, V]>[node._key, node._value];\n  }\n  find(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return new OrderedMapIterator<K, V>(curNode, this._header, this);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The specified key you want to get.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K) {\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    return curNode._value;\n  }\n  union(other: OrderedMap<K, V>) {\n    const self = this;\n    other.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n    return this._length;\n  }\n  * [Symbol.iterator]() {\n    const length = this._length;\n    const nodeList = this._inOrderTraversal();\n    for (let i = 0; i < length; ++i) {\n      const node = nodeList[i];\n      yield <[K, V]>[node._key, node._value];\n    }\n  }\n  // @ts-ignore\n  eraseElementByIterator(iter: OrderedMapIterator<K, V>): OrderedMapIterator<K, V>;\n}\n\nexport default OrderedMap;\n"]}